<docs>
  <members name="sqlclient">
    <GetTSqlBatchExtension>
      <summary>
        LINQ extensions for executing T-SQL code containing multiple batches.
      </summary>
      <remarks>
        <para>
          [Author's Note:  I hated having to write this code at all.  Microsoft already knows about some of the bugs[0] listed below,
          but refuses to fix them or, in the alternative, open source the relevant source code so I can fix them.  It makes a person
          gaze longingly at Linux and PostgreSQL.
        </para>
        <para>
          [0]: https://feedback.azure.com/forums/908035-sql-server/suggestions/32901208--go-in-2nd-half-of-nested-block-comments-breaks-b
        </para>
        <para>
          Several comments reference Extended Backus-Naur Form (EBNF) when explaining the lexical structure being parsed.
          A great introduction to EBNF is a .pdf titled 'EBNF: A Notation to Describe Syntax', located at
          https://www.ics.uci.edu/~pattis/misc/ebnf2.pdf.]
        </para>
        <para>
          Executing a T-SQL batch file that contains multiple batches (separated by GO statements) isn't easy.
        </para>
        <para>
          None of the Microsoft.Data.SqlClient.SqlCommand methods (ExecuteNonQuery(), ExecuteReader(), etc.)
          understand GO statements, so these methods will throw exceptions when encountering a GO statement.
          There are several other approaches, but all of them have bugs.  That lead to
          the creation of this class, which uses a lexical scanner to split the T-SQL batches into multiple strings,
          each of which can then be executed in the normal fashion.
        </para>
        <para>
          <h3>What's a GO Statement?</h3>
        </para>
        <para>
          The GO statement is a batch separator. Technically it's not a part of T-SQL, but is recognized and acted upon by the
          tools that process T-SQL, such as osql.exe, sqlcmd.exe, and SQL Server Management Studio (SSMS). GO can optionally have
          a positive integer argument "N", which executes the T-SQL batch N times.
        </para>
        <para>
          When one of those tools sees a GO statement, the tool sends the T-SQL preceding the GO statement to the server to
          be executed. Each batch is separate, in that variables declared in one batch are not visible in any other batches.
          Also, commands like CREATE statements must appear in a batch by themselves.
        </para>
        <para>
          <h3>What's the Problem?</h3>
        </para>
        <para>
          Sometimes an application needs to execute a T-SQL file containing multiple batches.
          This presents an immediate problem because the standard way an app executes T-SQL
          is thru the various Microsoft.Data.SqlClient.SqlCommand methods. As noted above, those methods will raise an exception
          when they hit a GO statement. Several solutions are available, but - with one exception - all are either buggy or incomplete.
          The next section goes over those solutions along with the problems of each.
        </para>
        <para>
          <h3>Solutions</h3>
        </para>
        <para>
          The first possible solution is to shell out to sqlcmd.exe and have it execute the T-SQL batches.
          Unfortunately this isn't feasible for several reasons.
        </para>
        <para>
          First, sqlcmd.exe (or osql.exe in older versions of SQL Server) might not be available to the application
          for a variety of reasons. It might either not be installed, or the app might not have sufficient permissions
          to run it. It would actually be surprising if that utility were accessible by an app in a production environment.
        </para>
        <para>
          Even if sqlcmd.exe can be executed, it has either one or two bugs where it cannot correctly parse legal GO statements
          (depending on sqlcmd.exe's version).
        </para>
        <para>
          The first bug, which we'll call Bug #1, involves a legally constructed comment containing a GO statment
          (note that T-SQL allows nested block comments). Some versions of sqlcmd.exe will throw a parsing exception
          when processing a comment like this:
        </para>
        <para>
          /*<br/>
          /**/<br/>
          GO<br/>
          */
        </para>
        <para>
          A comment with this structure is not an uncommon occurrence. Because T-SQL allows nested block comments, developers will
          frequently comment out a block of code by wrapping the block in /* and */ comment delimiters.
        </para>
        <para>
          The second bug (Bug #2), is similar in that it involves a trailing block comment. The documentation for GO
          clearly states that trailing comments are allowed, but doesn't say whether that's limited to only single-line
          comments, or includes both single-line comments and block comments.  So it should be assumed that both
          types of comments can appear after a GO statement. Unfortunately, this isn't true.
          Like Bug #1, some versions of sqlcmd.exe will throw a parsing exception when processing a comment like this:
        </para>
        <para>
          GO /**/
        </para>
        <para>
          Again, like Bug #1, this can easily happen as a matter of normal programming practice.  In the final analysis,
          trusting sqlcmd.exe to executing multiple batches has some significant risks.
        </para>
        <para>
          The second possible solution involves the use of either of two Microsoft libraries available via NuGet:
          SQL Server Management Objects (SMO), and Microsoft SQL Server Data-Tier Application Framework (DacFx).
        </para>
        <para>
          SMO provides a method - ExecuteNonQuery() - that recognizes GO statements.  However, that method suffers
          from Bug #1.  DacFx has a TSqlParser class that can split a T-SQL file containing GO statements into
          separate T-SQL fragments.  TSqlParser doesn't suffer from Bug #1, but it does have Bug #2.
          TSqlParser also has its own unique bug.  It will throw a parsing exception whenever a GO statement
          is followed by a number, as in a perfectly legal statement such as "GO 5".
        </para>
        <para>
          If pre-existing utilities and libraries can't handle the problem, it's time to turn to home-grown solutions.
          Because T-SQL is just text, it may be tempting to use a regular expression (regex) to split the T-SQL code on GO
          statements, resulting in a string array of T-SQL fragments that can each be individually executed.
        </para>
        <para>
          Any programmer familiar with regular expressions will immediately see why this solution falls somewhere between
          extremely difficult and impossible.  But I'll briefly list the reasons here so as to be complete.
        </para>
        <para>
          First, the word GO can appear in comments (see Bug #1), and string literals.  Naively splitting on GO will
          most likely result in the file being split in incorrect places.  Second, if a regex is first used to remove
          block comments, that regex can remove the wrong text because string literals can contain character sequences
          like '/*' and '*/'.  This would cause the comment-removal regex to remove the wrong text.
        </para>
        <para>
          The fourth solution is what's implemented in this class.  It uses a lexical scanner to perform a single pass
          of the T-SQL code, identifying and ignoring any comments it comes across.  All other text is copied to a string.
          When the scanner encounters a GO statement, the number of GO repetitions is determined (i.e. is the statement
          "GO n", or just "GO"?).  If 'n' is greater than one, the T-SQL fragement is wrapped in a WHILE loop so it will
          be executed 'n' times.  If 'n' is one, or isn't present at all, the T-SQL fragement is simply added to the
          resulting list of strings.
        </para>
      </remarks>
    </GetTSqlBatchExtension>
    <GetTSqlBatches>
      <summary>
      </summary>
      <returns>
      </returns>
      <param name="tsql"></param>
    </GetTSqlBatches>
    <AddDouble>
      <summary>
        Adds two doubles <paramref name="a"/> and <paramref name="b"/> and returns the result.
      </summary>
      <returns>
        The sum of two doubles.
      </returns>
      <example>
        <code>
          double c = Math.Add(4.5, 5.4);
          if (c > 10)
          {
          Console.WriteLine(c);
          }
        </code>
      </example>
      <exception cref="System.OverflowException">
        Thrown when one parameter is max
        and the other is greater than 0.
      </exception>
      See <see cref="Math.Add(int, int)"/> to add integers.
      <seealso cref="Math.Subtract(double, double)"/>
      <seealso cref="Math.Multiply(double, double)"/>
      <seealso cref="Math.Divide(double, double)"/>
      <param name="a">A double precision number.</param>
      <param name="b">A double precision number.</param>
    </AddDouble>
    <SubtractInt>
      <summary>
        Subtracts <paramref name="b"/> from <paramref name="a"/> and returns the result.
      </summary>
      <returns>
        The difference between two integers.
      </returns>
      <example>
        <code>
          int c = Math.Subtract(4, 5);
          if (c > 1)
          {
          Console.WriteLine(c);
          }
        </code>
      </example>
      See <see cref="Math.Subtract(double, double)"/> to subtract doubles.
      <seealso cref="Math.Add(int, int)"/>
      <seealso cref="Math.Multiply(int, int)"/>
      <seealso cref="Math.Divide(int, int)"/>
      <param name="a">An integer.</param>
      <param name="b">An integer.</param>
    </SubtractInt>
    <SubtractDouble>
      <summary>
        Subtracts a double <paramref name="b"/> from another double <paramref name="a"/> and returns the result.
      </summary>
      <returns>
        The difference between two doubles.
      </returns>
      <example>
        <code>
          double c = Math.Subtract(4.5, 5.4);
          if (c > 1)
          {
          Console.WriteLine(c);
          }
        </code>
      </example>
      See <see cref="Math.Subtract(int, int)"/> to subtract integers.
      <seealso cref="Math.Add(double, double)"/>
      <seealso cref="Math.Multiply(double, double)"/>
      <seealso cref="Math.Divide(double, double)"/>
      <param name="a">A double precision number.</param>
      <param name="b">A double precision number.</param>
    </SubtractDouble>
    <MultiplyInt>
      <summary>
        Multiplies two integers <paramref name="a"/> and <paramref name="b"/> and returns the result.
      </summary>
      <returns>
        The product of two integers.
      </returns>
      <example>
        <code>
          int c = Math.Multiply(4, 5);
          if (c > 100)
          {
          Console.WriteLine(c);
          }
        </code>
      </example>
      See <see cref="Math.Multiply(double, double)"/> to multiply doubles.
      <seealso cref="Math.Add(int, int)"/>
      <seealso cref="Math.Subtract(int, int)"/>
      <seealso cref="Math.Divide(int, int)"/>
      <param name="a">An integer.</param>
      <param name="b">An integer.</param>
    </MultiplyInt>
    <MultiplyDouble>
      <summary>
        Multiplies two doubles <paramref name="a"/> and <paramref name="b"/> and returns the result.
      </summary>
      <returns>
        The product of two doubles.
      </returns>
      <example>
        <code>
          double c = Math.Multiply(4.5, 5.4);
          if (c > 100.0)
          {
          Console.WriteLine(c);
          }
        </code>
      </example>
      See <see cref="Math.Multiply(int, int)"/> to multiply integers.
      <seealso cref="Math.Add(double, double)"/>
      <seealso cref="Math.Subtract(double, double)"/>
      <seealso cref="Math.Divide(double, double)"/>
      <param name="a">A double precision number.</param>
      <param name="b">A double precision number.</param>
    </MultiplyDouble>
    <DivideInt>
      <summary>
        Divides an integer <paramref name="a"/> by another integer <paramref name="b"/> and returns the result.
      </summary>
      <returns>
        The quotient of two integers.
      </returns>
      <example>
        <code>
          int c = Math.Divide(4, 5);
          if (c > 1)
          {
          Console.WriteLine(c);
          }
        </code>
      </example>
      <exception cref="System.DivideByZeroException">
        Thrown when <paramref name="b"/> is equal to 0.
      </exception>
      See <see cref="Math.Divide(double, double)"/> to divide doubles.
      <seealso cref="Math.Add(int, int)"/>
      <seealso cref="Math.Subtract(int, int)"/>
      <seealso cref="Math.Multiply(int, int)"/>
      <param name="a">An integer dividend.</param>
      <param name="b">An integer divisor.</param>
    </DivideInt>
    <DivideDouble>
      <summary>
        Divides a double <paramref name="a"/> by another double <paramref name="b"/> and returns the result.
      </summary>
      <returns>
        The quotient of two doubles.
      </returns>
      <example>
        <code>
          double c = Math.Divide(4.5, 5.4);
          if (c > 1.0)
          {
          Console.WriteLine(c);
          }
        </code>
      </example>
      <exception cref="System.DivideByZeroException">
        Thrown when <paramref name="b"/> is equal to 0.
      </exception>
      See <see cref="Math.Divide(int, int)"/> to divide integers.
      <seealso cref="Math.Add(double, double)"/>
      <seealso cref="Math.Subtract(double, double)"/>
      <seealso cref="Math.Multiply(double, double)"/>
      <param name="a">A double precision dividend.</param>
      <param name="b">A double precision divisor.</param>
    </DivideDouble>
  </members>
</docs>